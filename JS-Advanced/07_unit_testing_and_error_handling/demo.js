// -----------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
//
//                          ERROR HANDLING
//
//  - Фундаментален принцип, при който дадено приложение трябва да:
//      • направи това, което името му предполага;
//      • индикира грешка;
//      • всеки друг вариант НЕ Е коректно поведение;
//  - Нашите функции трябва да са самоописателни
//  - Да предвидим, къде може да възникне граничен случай и да добавим съответния код, който да ни изкара от граничния случай;
//
//  - Type of Errors:
//      • Syntax Errors: грешка в изписването, пр: изпусната е някоя точка, грешно изписан метод или подобно;
//      • Runtime Errors: появяват се по време на изпълнение(след компилация), пр: реферирали сме променлива, която не съществува;
//      • Logical Errors: грешки, при които приложението се изпълнява нормално, но резултатът не отговаря на очакваното поведение, наричаме го БЪГ(буг), следва дебъгване;
//
//  - Функция, която НЕ изпълнява това, което името й подсказва, трябва да:
//      • върне специална стойност: undefined / false / -1; Може да се внедри в IF конструкция и да евентуално върне грешка;
//          let str = 'Hello, SoftUni';
//          console.log(str.indexOf('Sofia')); // връща -1;
//      • "хвърли" exception / error; Ако получим exception(изключение) приложението спира
//          let arr = new Array(-1);                // RangeError
//          let bigArr = new Array(999999);         // RangeError
//          let index = undefined.indexOf("hi");    // TypeError
//          console.log(George);                    // ReferenceError
//          console.print('hi');                    // TypeError
//      • Можем сами да си създаваме грешки, които да "хвърляме", чрез throw:
//          throw new Error("Invalid state");           // General Error
//          throw new RangeError("Invalid index");      // Range Error
//          throw new TypeError("String expected");     // Type Error
//          throw new ReferenceError("Missing age");    // Reference Error
//      • изключенията показват необичайни обстоятелства на изпъленение;
//      • Обикновено се използват в try-catch конструкцията:
function showMsg(input) {
    if (typeof input !== 'string') {
        throw new Error('Not a string');
    }
    return input;
}
console.log(showMsg('hi')); // ще върне "hi";

try {
    console.log(showMsg(99)); // не е стринг
} catch (err) {
    // "err" може да бъде кръстено както искаме !!!;
    console.log('Wrong input:', err.name); // връща тип на грешката => Wrong input: Error
    console.log('Wrong input:', err.message); // връща съобщението, което сме "хвърлили" при проверката => Wrong input: Not a string
    // console.log('Wrong input:', err.stack); // това, което по принцип отпечатва, ако приложението гръмне;
    // console.log('Wrong input:', err); // това, което по принцип отпечатва, ако приложението гръмне;
}
//
//
// -----------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
//
//                          UNIT TESTING
//
//  - Единичен тест; тест на едно нещо(една функция). Идеята на теста е да провери дали нещото работи коректно.
//  - В общия случай това трябва да става АВТОМАТИЗИРАНО.
//  - Изпълняваме кода и очакваме конкретен резултат. Ако резултатът не е този, който очакваме, значи има проблем и тестът не минава;
//
//  - import/export from other modules(files):
import { sum, product, devide } from './fileForExport.js';
console.log(sum(3, 2));
console.log(product(3, 3));
console.log(devide(22, 11));

//  - използване на Mocha и Chai за автоматизиране на тестовете:
//      1) за ВСЕКИ проект се инсталират, използвайки терминал-а в папката на самия проект:
//          • npm init -y
//          • npm install -D mocha
//          • npm install -D chai
//      2) добавяме "type": "module" в package.json файла; КАКТО И преименуваме следния ред на: "test": "mocha"
//      3) създаваме си нашия код:

function addNumbers(a, b) {
    if (typeof a != 'number' || typeof b != 'number') {
        throw new TypeError('Must provide a number');
    }

    return a + b;
}
export { addNumbers };

//      4) създаваме *sameName*.test.js файл и описваме какво искаме да тестваме в него;
//      5) РЪНВАМЕ *sameName*.test.js файла, ИЗПОЛЗВАЙКИ ТЕРМИНАЛ => npm test *sameName*.test.js

//  - Unit Testit Approaches:
//      1) "Code First" (classic approach);
//      2) "Test First" => Test-driven development (TDD);
//          • TDD помага да намираме грешките по-рано => избягваме преправянето на код-а;
//          • Пишейки код, който да удовлетворява тестовете => по-малък шанс за грешка;
//          • Тестовете ще бъдат по-изчерпателни отколкото ако са написане СЛЕД код-а;
//
//      3) КАКВО да тестваме:
//          • (1) happy path    => тестваме с произволни стойности на параметрите, отговарящи на условията;
//          • (2) edge cases    => тестваме с такива стойности на параметрите, които са, като частни(гранични/редки), но отговарящи на условията;
//          • (3) validation    => тестваме с такива стойности на параметрите, които НЕ СА отговарящи на условията;
//          • (4) test overload => тестваме с комбинация от рандом параметри, за да направим още 2-4 допълнителни теста;
//
//
//
//
//
//
//
